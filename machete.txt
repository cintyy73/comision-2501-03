Clase 12 — Introducción a la Asincronía en JavaScript
=====================================================

1. ¿Por qué existe la asincronía?
   - JavaScript corre en un solo hilo.
   - Evitar bloquear la interfaz de usuario.
   - Analogía: pedir café y hacer otras cosas mientras esperas.

   
   - Imagina que pedís un café en una cafetería (tarea lenta).
   - Mientras esperás, podés revisar tu celular o charlar (otras tareas).
   - Cuando el café está listo, el barista te llama (evento).
   - En JavaScript, esto es como enviar una solicitud y seguir ejecutando otras cosas hasta que la respuesta llega.

   
   - La asincronía permite que el navegador no se "congele" mientras espera respuestas de servidores, carga de imágenes, etc.

2. Síncrono vs Asíncrono
   - Diferencias clave.
   - Ejemplo simple con setTimeout.

    
    - Síncrono: cada línea se ejecuta una tras otra. Si una función tarda, todo lo demás espera.
    - Asíncrono: se delegan tareas lentas (como setTimeout) y el código sigue ejecutándose.
    - Ejemplo:
       ```js
       function saludar() { console.log("Hola"); }
       function esperarYResponder() { setTimeout(() => { console.log("Gracias por esperar"); }, 2000); }
       saludar();
       esperarYResponder();
       console.log("Fin");
       ```
    - Salida: Hola, Fin, Gracias por esperar (después de 2 segundos).

    
    - Síncrono bloquea el hilo principal. Asíncrono permite que la UI siga respondiendo.

3. ¿Cómo funciona la asincronía en el navegador?
   - Web APIs, Call Stack, Event Loop, Colas de tareas.
   - Explicación visual y con analogías.

   
   - El navegador tiene un solo hilo para ejecutar JS.
   - Cuando encuentra una tarea asíncrona (setTimeout, fetch), la delega al Web API del navegador.
   - El resto del código sigue ejecutándose.
   - Cuando la tarea termina, se pone en una "cola de tareas".
   - El Event Loop revisa si el hilo principal está libre y ejecuta la tarea pendiente.

   
   - El Event Loop es el mecanismo que organiza cuándo se ejecutan las tareas asíncronas.
   - Las Web APIs son funciones que el navegador presta a JS para trabajar con temporizadores, eventos, red, etc.

4. Ejemplos sencillos de asincronía
   - Usando setTimeout.
   - Usando Promesas y .then.
   - Usando async/await.
   - Explicación detallada de cada ejemplo.

    
    - setTimeout: programa una tarea para el futuro sin bloquear el código actual.
    - Promesa y .then: crea una "caja" que promete un resultado futuro. Cuando está listo, .then lo recibe.
    - async/await: permite escribir código que espera resultados de forma legible y ordenada.

    Ejemplo setTimeout:
    ```js
    console.log("Inicio");
    setTimeout(() => { console.log("Esto se ejecuta después de 2 segundos"); }, 2000);
    console.log("Fin");
    // Salida: Inicio, Fin, Esto se ejecuta después de 2 segundos
    ```

    Ejemplo Promesa:
    ```js
    const promesa = new Promise((resolve, reject) => {
       const exito = true;
       if (exito) { resolve("Todo salió bien ✅"); } else { reject("Algo salió mal ❌"); }
    });
    promesa.then((mensaje) => { console.log(mensaje); }).catch((error) => { console.log(error); });
    // Salida: Todo salió bien ✅
    ```

    Ejemplo async/await:
    ```js
    function esperar() {
       return new Promise((resolve) => {
          setTimeout(() => { resolve("¡Listo después de 2 segundos!"); }, 2000);
       });
    }
    async function main() {
       console.log("Inicio");
       const resultado = await esperar();
       console.log(resultado);
       console.log("Fin");
    }


  //Ejemplo async/await:
function esperar() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("¡Listo después de 2 segundos!");
    }, 2000);
  });
}
async function main() {
  console.log("Inicio");
  const resultado = await esperar();
  console.log(resultado);
  console.log("Fin");
}
main();
      // Explicación ampliada sobre async y await:
      // Explicación fácil:
      // --------------------------------------------------
      // - async y await son palabras que ayudan a trabajar con código que tarda en completarse.
      // - async se pone antes de una función para decirle a JavaScript que esa función va a esperar cosas.
      // - await se usa dentro de una función async para "pausar" el código hasta que termine una tarea (como esperar una respuesta del servidor).
      // - Así, podés escribir código que parece normal y ordenado, pero en realidad está esperando sin bloquear la página.
      // Ejemplo fácil:
      // Imagina que pedís una pizza por internet:
      // - Usás await para esperar a que llegue la pizza antes de seguir con el resto de tu código.
      // - Mientras tanto, la página sigue funcionando y no se congela.
      // ----------------------------------------- 
      // - async se coloca antes de una función para que devuelva una Promesa automáticamente.
      // - await se usa dentro de una función async para "pausar" la ejecución hasta que la Promesa se resuelva.
      // - Esto hace que el código sea más legible y fácil de seguir, como si fuera síncrono, pero sin bloquear el hilo principal.
      // - Si la Promesa se resuelve, await devuelve el resultado. Si la Promesa se rechaza, lanza un error que puede capturarse con try/catch.

      // Ejemplo con manejo de errores:
      async function ejemploError() {
         try {
            const ok = await esperar();
            console.log("Resultado:", ok);
            throw new Error("Simulando error");
         } catch (e) {
            console.log("Ocurrió un error:", e.message);
         } finally {
            console.log("Esto se ejecuta siempre");
         }
      }
      ejemploError();

      // Ventajas de async/await:
      // - Permite escribir flujos asíncronos complejos de forma sencilla.
      // - Facilita el manejo de errores con try/catch.
      // - Hace que el código sea más parecido al síncrono, pero sin bloquear la interfaz.
    main();
    // Salida: Inicio, (espera 2 segundos), ¡Listo después de 2 segundos!, Fin
    ```

5. ¿Cuándo se usan estas técnicas en la vida real?
   - setTimeout: mensajes temporales, animaciones.
   - Promesas: peticiones a APIs, carga de recursos.
   - async/await: flujos complejos, autenticación, carga de datos.

   
   - setTimeout: mostrar un mensaje de "Guardado exitosamente" y ocultarlo después de unos segundos.
   - Promesas: pedir datos a un servidor y mostrar el resultado cuando llegue.
   - async/await: autenticar a un usuario, luego cargar su perfil y mostrarlo en pantalla.

   
   - La asincronía es clave para que las aplicaciones web sean rápidas y responsivas.

6. Promesas en profundidad
   - Estados de una promesa.
   - Métodos: .then, .catch, .finally.
   - Composición: Promise.all, Promise.race, etc.

    ¿Cómo funcionan resolve y reject?
    ---------------------------------
    Cuando creás una Promesa, recibís dos funciones:
    - `resolve(valor)`: se llama cuando la tarea termina correctamente. El valor se recibe en `.then`.
    - `reject(error)`: se llama cuando la tarea falla. El error se recibe en `.catch`.

    Ejemplo 
    ```js
    const promesa = new Promise((resolve, reject) => {
       const exito = true; // Simula si la tarea sale bien o mal
       if (exito) {
          resolve("Todo salió bien ✅"); // La promesa se resuelve
       } else {
          reject("Algo salió mal ❌");   // La promesa se rechaza
       }
    });

    promesa
       .then(mensaje => console.log(mensaje)) // Si se resuelve, muestra el mensaje
       .catch(error => console.log(error));   // Si se rechaza, muestra el error
    ```

    En resumen:
    - Usá `resolve` para indicar éxito y continuar el flujo normal.
    - Usá `reject` para indicar error y manejarlo con `.catch`.
    Esto permite controlar el resultado de operaciones asíncronas de forma ordenada.

    
    - Una promesa puede estar pendiente, cumplida o rechazada.
    - .then se ejecuta si la promesa se cumple.
    - .catch se ejecuta si la promesa falla.
    - .finally se ejecuta siempre, pase lo que pase.
    - Promise.all permite esperar varias promesas a la vez.

    Ejemplo:
    ```js
    const promesa = new Promise((resolve, reject) => {
       setTimeout(() => {
          const exito = Math.random() > 0.5;
          if (exito) { resolve("OK ✅"); } else { reject("Error ❌"); }
       }, 1000);
    });
    promesa
       .then((msg) => console.log("then:", msg))
       .catch((err) => console.log("catch:", err))
       .finally(() => console.log("fin"));
    ```

    
    - Las promesas permiten manejar tareas asíncronas de forma ordenada y legible.

7. Ejemplo de uso real (sin código)
   - Autenticación de usuario: esperar respuesta del servidor.
   - Carga de perfil: esperar datos antes de mostrar la pantalla.
   - Mostrar spinner mientras se espera una respuesta.

   
   - El usuario ingresa sus datos y presiona "Ingresar".
   - La aplicación envía los datos al servidor (tarea asíncrona).
   - Mientras espera, muestra un spinner o mensaje de "Cargando...".
   - Cuando el servidor responde, la aplicación muestra el perfil del usuario.

   
   - Este flujo permite que la interfaz siga respondiendo y el usuario vea que la aplicación está trabajando, aunque la tarea tarde.



 
